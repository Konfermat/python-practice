https://developer.mozilla.org/ru/docs/Learn_web_development/Extensions/Server-side/Django/Introduction

==================================================================================
URLs: Маршрутизатор нужен для перенаправления запросов.
View: Это функция обработчика запросов. Принимает HTTP запросы и отправляет ответы.
    Функция имеет доступ к необходимым данным и делегирует ответы в 
    шаблоны через модели.
Models: Модели это объекты Pyhon которые определяют структуру данных приложения и 
    предоставляют механизмы управления(добавления, изменения, удаления) 
    и выполнения запросов к базе данных.
Templates: Текстовый файл определяющий структуры или разметку страницы. 
    View будет динамически создавать странци по шаблону, используя HTML шаблоны и 
    заполняя их данными с Models.
    Шаблон может быть использовандля определения структуры файлов любых типов,
    не обязательно HTML.

==================================================================================
Отправка запросов в правльное view urls.py
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('book/<int:id>/', views.book_detail, name='book_detail'),
        path('catalog/', include('catalog.urls')),
        re_path(r'^([0-9]+)/$', views.best),
    ]      
    urlpatterns это объект, хранящий список функций path и, или re_path(хз пока).
    Первый аргумент в обоих методах, маршрут(шаблон), который будет сопоставлен. 
    В методе path угловые скобки нужные для определения частей URL адреса,
    которые захвачены и переданны во view в качестве именованных аргументов.
    Второй аргумент это еще одна функция, которая будет вызываться при сопоставлении
    шаблона. name нужен для определения названия функции, в случая предположительного 
    изменения шаблона.

==================================================================================
Обработка запросов views.py
    Отображения(views) принимает http запросы и возвращает http ответы. 
    Между этим они используют другие ресурсы фреймворка для доступа к базам данных,
    шаблонам визуализации и тд.

    В приведенном ниже примере показана минимальная функция представления index() 
    которая могла быть вызвана нашим сопостовителем URL-адресов в предидущем разделе. 
    Как и все функции отображения (view), она получает объект HttpRequest в качестве 
    параметра (request) и возвращает объект HttpResponse. В этом случае мы ничего 
    не делаем с запросом и просто возвращаем 
    hard coded в виде HttpResponse('Hello from Django!')

    ## filename: views.py (Django view functions)

    from django.http import HttpResponse

    def index(request):
        # Получить HttpRequest — параметр запроса
        # Выполнить операции, используя информацию из запроса.
        # Вернуть HttpResponse
        return HttpResponse('Hello from Django!')

==================================================================================
Определение данных модели models.py
    Веб приложения обрабатывают и запрашивают данные через объекты Python,
    называемые модели. Модели определяют структуру хранимых данных, включая типы полей,
    их размер, параметры списка выбора и тд. Определение моделей не зависит от 
    выбранной базы данных.
    В примере ниже показана простая модель Django для объекта Team.
    Класс Team наследуется от класса models.Model. Он определяет имя команды 
    и командный уровень в качестве полей символов, максимальное количество 
    символов которые могут быть сохранены для каждоей записи.
    Team_level может быть одним из нескольких значений, поэтому мы определяем его 
    как поле выбора и предостовляем сопоставление между отображаемыми вариантами и 
    хранимыми данными вместе со значениями по умолчанию. 
    # filename: models.py

    from django.db import models

    class Team(models.Model):
        team_name = models.CharField(max_length=40)

        TEAM_LEVELS = (
            ('U09', 'Under 09s'),
            ('U10', 'Under 10s'),
            ('U11', 'Under 11s'),
            ...  #список других командных уровней
        )
        team_level = models.CharField(max_length=3,choices=TEAM_LEVELS,default='U11')

================================================================================== 
Запросы данных views.py
    Модель Django предостовляет простой API запросов для бд. Поиск может осуществлятся 
    по нескольким полям одновременно, используя различные критерии (такие как:
    exact("точный"), case-insensetive("без учета регистра"), greater than("больше чем")
    и тд) и может поддерживать сложные выражения (например, вы можете указать 
    поиск в командах U11, у которых есть имя команды, начинающееся 
    с «Fr» или заканчивается на «al»).
    
    Фрагмент кода показывает функцию view(обработчик ресурсов) для отражения 
    всех команд U09(Обратите внимание, как эти критерии передаются функции filter() 
    в качестве с именем поля и типом соответствия разделенным двойным подчеркиванием:
    team_leve__exact)

    ## file name: views.py
    from django.shortcuts import render
    from .models import Team

    def index(request):
        list_teams = Team.objects.filter(team_level__exact="U09")
        context = {'youngest_teams': list_teams}
        return render(request, '/best/index.html', context)
    
    Данная функция index() использует функцию render() для того, 
    чтобы создать HttpResponse, котрый будет отправлен назад браузеру. 
    Эта функция является ярлыком; она создает HTML-файл, комбинируя указанный 
    HTML-файл, комбинируюя указанный HTML-шаблон и некоторые данные для вставки в 
    шаблон(они передаются в "context").

================================================================================== 
Вывод данных (HTML-шаблоны)
    Системы шаблонов позволяют указать структуру выходного документа, используя 
    заполнители для данных, которые будут вствлены при генерировании страницы. 
    Django имеет свою систем и также может поддерживать jinja2.

    Фрагмент кода показывает, как может выглядеть HTML-шаблон, вызванный функцией
    render() из предидущего раздела. Этот шаблон был написан с предположением, 
    что во время отрисовки он будет иметь доступ к переменной списка, 
    названной youngest_teams (содержащейся в контекстной пременной, внутри 
    render() выше). Внутри склета HTML имеем выражение, которое сначала проверяет,
    существует ли переменная yongest_teams, а затем повторяет её в цикле for.
    При каждом повторе шаблон отображает значение team_name каждой команды в 
    элементе <li>

    ## filename: best/templates/best/index.html

    <!DOCTYPE html>
    <html lang="eng">
    <head>
        <meta charset="utf-8">
        <title>Home page</title>
    </head>
    <body>
        {% if youngest_teams %}
            <ul>
                {% for team in youngest_teams %}
                    <li>{{ team.team_name }}</li>
                {% endfor %}
            </ul>
        {% else %}
            <p>No teams are available.</p>
        {% endif %}
    </body>
    </html>

================================================================================== 

Что еще можно сделать?
    В предидущих разделах показанны основные особенности, которые вы будете 
    использовать почти в каждом веб-приложении: сопоставление URL-адресов,
    отображение, модели и шаблоны. Также Django предоставляет несколько других вещей:
        *Формы: HTML-формы используются для сбора пользовательских данных для
            обработки на сервере. Django упрощает проверку и обработку формы.
        *Аутентификация пользователя и разрешения: Django включает надежную
            систему аутентификации и авторизации пользователей.
        *Кэширование: Создание динамического контента намного более интенсивно 
            (и медленее), чем обслуживание статического содержимого. Django 
            обеспечивает гибкое кэширование позволяющее хранить часть или всю
            страницу.
        *Админ-панель: Административная панель включена по умолчанию при создании
            приложения с основного каркаса.
        *Сериализация данных (преобразование в последовательную форму):
            Django упрощает сериализацию и обслуживание ваших данных в таких 
            форматах как XML или JSON. Помогает при работе с сайтами без 
            отображения или при создании сайта, на котором клиентский код 
            обрабатывает весь рендеринг данных.
================================================================================== 


================================================================================== 

